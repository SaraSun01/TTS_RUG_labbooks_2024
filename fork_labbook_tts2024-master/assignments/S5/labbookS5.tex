%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Do not alter this block (unless you're familiar with LaTeX)
\documentclass{../labbook}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Fill in the appropriate information below
\lhead{Shiran Sun}
\rhead{Speech Synthesis I}
\chead{\textbf{Lab Book S5. Due: \textbf{FRI 24.01.2025 23:59} CET}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\section{Lab Book S5}
\noindent In this lab book you will work with gTTS (Google Text-to-Speech), a Python library and CLI tool to interface with Google Translate's text-to-speech API. 
You can find the documentation \href{http://gtts.readthedocs.org/}{here}.

\begin{problem}{1}{10}{gTTS: Synthesizing a dialogue with two speakers}

\subsection*{Installing and trying out GTTS}
GTTS can be installed out of the box. For Debian-based Linuxes you can use 
\begin{verbatim} 
    apt install python3-gtts
\end{verbatim} (if you are using Google colab, prefix the shell commands with an exclamation mark, e.g. 
\texttt{!apt install python3-gtts} or \texttt{!pip install gtts}).
\smallskip

\subsubsection*{Task:}
\noindent Let's imagine you need collect a lot of data to evaluate an ASR system that has been used by the local call center. There is no time to collect a lot of data and you need to be creative, and you decided to synthesize some data. 

You are starting with synthesizing a phone call dialogue between two speakers and at the same time you were asked to do some pre-processing and censor some words by substituting them with other words. 

For this task you will need to generate a transcript using chatGPT. 
Ask it to generate a dialogue between two friends. These two speakers should take turns in their conversation several times. 
Decide on the topic of the dialogue yourself: it could be pets, school subjects, food items - anything you want and that would give you as rich phoneme representation as possible. Also make sure to specify that pets/subject/food items/whatever would have strange names. It could look something like:
    
transcript = ```Friend 1: Hey! How's it going?
    
Friend 2: Hey! I'm good, thanks. Just got back from the park with Grog Strongjaw. He had a blast chasing squirrels.

Friend 1: Grog Strongjaw always has so much energy! I wish Chancellor Zorg had half his enthusiasm.

Friend 2: Well, you know how it is with labs. They're like perpetual motion machines. How's Chancellor Zorg doing?```


Below is the step-by-step task description with some suggestions:
\begin{enumerate}
      \item Think of a way to prompt ChatGPT to have a phonetically rich conversation and generate it.
      
      \item Given your conversation transcript, you will need to synthesize spoken dialogue using gTTS with alternating speaker utterances. First step could be to split your transcripts by speaker turns and run TTS on each utterance.
    
    However, before generating speech, you need to do some customization on your transcript using the gTTS' Speech corrections (word substitution). You will need to substitute those strange names of the pets/subjects/foods/whatever with nice things of your choice (e.g., ``fluffball'', ``sunshine'', or whatever you want, whatever brings you joy).

    \item The next step could be creating the temporary sequential audio fragments by iterating through enumerated list of utterances and generating one of the two different variants of English voices depending on the speaker. 
    For example, you could take Australian English speaker voice for friend 1 and UK English speaker voice for friend 2 (or choose two other voices from the ones that described in \href{https://gtts.readthedocs.io/en/latest/module.html}{the documentation}). Something like:
    \begin{verbatim}
    if speaker == "friend_1":
      tts = gtts.gTTS(utterance, lang="en", tld="com.au")
      tts.save(outputfile)
    else:
      tts = gtts.gTTS(utterance, lang="en", tld="co.uk")
      tts.save(outputfile)
    \end{verbatim}

    \item Then you will need to combine your audio files of utterances into one recording of a dialogue (e.g., you can use librosa and pandas for the task). 
    
    \item Bonus part [1bpts]. If you want to make the task a bit more challenging, you can imitate a phone conversation\footnote{this would be more common in call centers} and make each speaker's recordings channel specific.
    
\end{enumerate}
\subsection*{Submission}
\noindent Alongside with this LaTeX file with your reflections (if any) and desccription of the process, commit the complete code you used for the task as well as the transcript of the dialogue if you used a separate file to store it. Also commit your resulting audio file just in case (I would still expect it be generated by your code when I run it). 
Make sure the code works "as is" and doesn't require editing paths, providing commandline argument and so on. Don't forget to write clear comments for your code.

\end{problem}

\begin{solution}

\subsection{Reflections:}
\begin{itemize}
\item Challenges: The initial challenge involved handling audio files in WAV format. Since librosa primarily works with WAV or similar formats, we also need to consider which libraries can be used to put together the WAV audio and ensure that the output sound quality is not affected.
The other consideration was whether all audio files had the same sampling rate. 
\item Solutions: Firstly, concatenating audio data incrementally ("np.concatenate()") provided a simple and effective way to combine multiple audio files while maintaining data integrity. 
Meanwhile, "sf.write()" is used to save the merged audio data to the WAV file format. Since the audio data has been converted to a numpy array, soundfile can easily write it back to a file and save it as a lossless WAV file.
And by using "sr=None", the script preserved the original sampling rate of each file. This approach avoided unnecessary resampling and kept the process efficient.
\item Learnings: Gained insights into handling multiple files in sequence and combining them programmatically. Consolidated the use of librosa for loading and processing audio files while retaining key attributes like sampling rate.
\end{itemize}

\subsection{Description of the Process:}
\begin{itemize}
\item Task Objectives:The main goal was to merge several audio files (generated from gTTS for a conversation) into a single continuous dialogue audio file.
\item Implementation Steps:\\
1.Prompt ChatGPT to generate a phonetically rich conversation: To generate eligible dialogues, I used the assignment's requirements to describe my prompt as specifically as possible, i.e.,"Please generate a dialogue between two friends. These two speakers should take turns in their conversation several times. The topic of the dialogue could be pets and that would give me as rich phoneme representation as possible. Also make sure to specify that pets would have strange names. " and give a sample dialogue from the assignment for reference.\\
2.Customise the transcribed text before generating speech: Creat a dictionary to replace the pet's name with a more interesting or pleasant word (such as ‘fluffball’ or ‘sunshine’).\\
3.Create a function to replace strange names with the substitutions provided.\\
4.Iterate over all utterances to generate temporary audio pieces based on the speakers with different accents: First select two different English accents (e.g. Australian English and British English) to represent the two speakers. The gTTS library is then used to specify language and regional parameters (e.g. lang=‘en’, tld=‘com.au’ and tld=‘co.uk’) by speaker. Finally the generated speech is saved as separate audio files.\\
5.Concatenate audio files: Combine each individual audio file into a complete audio recording of the dialogue, using Python librosa, numpy, soundfile and other libraries to accomplish the audio concatenation task.
\item Final Output: Generated a single WAV file (merged\_dialogue.wav) containing all concatenated dialogue in the correct order. The output preserved the original sampling rate and provided smooth transitions between audio clips.

\end{itemize}
\end{solution}
\end{document}
